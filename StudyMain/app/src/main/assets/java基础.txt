1,对象的生命周期?(强引用，弱引用，软引用)
    创建阶段（Creation）：为对象分配存储空间，父类到子类构造函数的调用
    应用阶段（Using）：对象至少被一个强引用持有着。
    不可视阶段（Invisible）：执行已经超出了该对象的作用域了
    不可到达阶段（Unreachable）：对象不再被任何强引用所持有
    可收集阶段（Collected）、
    终结阶段（Finalized）：等待垃圾回收器对该对象空间进行回收
    释放阶段（Free）：内存空间进行回收或者再分配了，则该对象彻底消失了，

2,类的生命周期？
一个java类的完整的生命周期会经历 加载、连接、初始化、使用、和卸载 五个阶段
    加载：
    连接：为类的静态变量分配内存并设为jvm默认的初值，对于非静态的变量，则不会为它们分配内存
    初始化：如果一个类被直接引用，就会触发类的初始化（new 对象，直接使用例如main()入口，反射实例化对象）
    使用：　主动使用，　被动使用
    卸载：　满足哪些情况会使类卸载

注意：
java的字节码文件被加载到方法区中后，会在堆中实例化一个java.lang.Class类的对象，

在类使用完之后，如果满足下面的情况，类就会被卸载：
（１）该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
（２）加载该类的ClassLoader已经被回收。
（３）该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
    如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。

使用阶段包括主动引用和被动引用，主动饮用会引起类的初始化，而被动引用不会引起类的初始化。

被动使用：
引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
定义类数组，不会引起类的初始化。
引用类的常量，不会引起类的初始化。


3,java虚拟机中的几个比较重要的内存区域

方法区：在java的虚拟机中有一块专门用来存放已经加载的类信息、常量、静态变量以及方法代码的内存区域，叫做方法区。
常量池：（线程共享）常量池是方法区的一部分，主要用来存放常量和类中的符号引用等信息。
堆区：（线程共享）用于存放类的对象实例。
虚拟机栈区：（线程私有）也叫java虚拟机栈，是由一个一个的栈帧组成的后进先出的栈式结构，栈桢中存放方法运行时产生的局部变量、方法出口等信息。当调用一个方法时，虚拟机栈中就会创建一个栈帧存放这些数据，当方法调用完成时，栈帧消失，如果方法中调用了其他方法，则继续在栈顶创建新的栈桢。
本地方法栈： 使用 JNI 才会涉及

java虚拟机总共分为五个区域，
三个是线程私有：程序计数器，虚拟机栈，本地方法栈，
两个是线程共享：堆，方法区。


4，内部类（Inner Class）和静态内部类（Static Nested Class，嵌套类）的区别
    1） 它的创建是不需要依赖于外围类的。
    2） 它不能使用任何外围类的非static成员变量和方法。
    实际上静态内部类的使用和一般的类没有任何区别。
　

5,java中的异常：Throwable、Exception、Error,try-catch-finally 块，throw、throws
    Java标准库内建了一些通用的异常，这些类以Throwable为顶层父类。Throwable又派生出Error类和Exception类。
    throw 异常抛出语句，例如：
            if(user  == null)
                    throw new IllegalArgumentException("User对象为空");
　   良好的编程习惯是：在try块中打开资源，在finally块中清理释放这些资源。
    throws是方法可能抛出异常的声明:
              public void function() throws Exception{......}

    自己进行异常处理，处理的时候有两种方式，要么自己捕获异常（也就是try catch进行捕捉），要么声明抛出一个异常（就是throws 异常~~）


6,谈谈 Java 反射机制，动态代理是基于什么原理？
反射机制: 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；
这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。
前提是可以获取到这个类的对象或者知道类的全名
动态代理：
 InvocationHandler 接口和 Proxy 类
https://blog.csdn.net/self_study/article/details/55050627
简单举例：https://www.cnblogs.com/summerpxy/p/4929113.html
动态代理的基本步奏：
　　1)implements InvocationHandler, 特别是　invoke　方法
        Object invoke(Object proxy, Method method, Object[] args) throws Throwable
        //proxy:　　指代我们所代理的那个真实对象
        //method:　　指代的是我们所要调用真实对象的某个方法的Method对象
        //args:　　指代的是调用真实对象某个方法时接受的参数

　　2)使用 Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
    　创建一个代理对象的类.
　　　
　适用对象：不知道某个已加载类的源码，但是想在这个类的方法中做一些小动作


7,谈谈接口和抽象类有什么区别？
1)	在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，
这是抽象类的优势；接口中只能有抽象的方法。
2)	一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。



8,java 容器,列举java的集合和继承关系.




9,hash冲突
HashMap中调用hashCode()方法来计算hashCode。
由于在Java中两个不同的对象可能有一样的hashCode,所以不同的键可能有一样hashCode，从而导致冲突的产生。


10 概念（三种引用强度依次递减）
强引用，普遍使用。如果持有强引用没就不会被回收
软引用：只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，
        并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
弱引用：在垃圾回收器线程扫描时回收。
虚引用，


11， 如果该对象重写了 finalize()方法，并在这个方法中成功自救(将自身赋予某个引用)，那么这个对象不会被回收。


12，对象处于存活的状态的2种方法：
    引用计数法： 不能解决对象之间相互循环引用的问题
    可达性分析（根搜索算法）：所谓“GC Roots”其实是一组必须活跃的引用，
                            要实现上述的效果的前提就是必须能完整的枚举出所有的GC Roots
    Java中可作为GC Roots对象的有如下几种：
        Java栈中的引用的对象
        本地方法栈中JNI引用的对象
        方法区中运行时常量池引用的对象
        方法区中静态属性引用的对象
        运行中的线程
        由引导类加载器加载的对象
        GC控制的对象

13，Java 类加载器？双亲委托机制 和 全盘负责机制
    某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，
    如果父类加载器可以完成类加载任务，就成功返回；
    只有父类加载器无法完成此加载任务时，才自己去加载。

使用双亲委托模式优点?
1)因为这样可以避免重复加载 2）越是基础的类，越是被上层的类加载器进行加载，保证了java程序的稳定运行

全盘负责 的意思？
  是指当一个ClassLoader装载一个类时，除非显示地使用另一个ClassLoader，
    则该类所依赖及引用的类也由这个CladdLoader载入。


14，LRU Cache原理和实现
   原理：最近使用的数据和新插入的数据放在表头，达到指定大小时，淘汰链表尾部的数据
   实现： 使用一个链表保存缓存数据


Android窗口管理
https://blog.csdn.net/self_study/article/details/55050627


15,进程和线程的区别？
    进程和线程的主要差别在于它们是不同的操作系统资源管理方式。
    进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，
    而线程只是一个进程中的不同执行路径。
    线程有自己的堆栈和局部变量，
    但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，
    所以多进程的程序要比多线程的程序健壮，
    但在进程切换时，耗费资源较大，效率要差一些。但
    对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程

16，hash碰撞的原因：
   常见的hash算法是 取模法，举例：
   假设hash表的大小为9（即有9个槽），现在要把一串数据存到表里：5,28,19,15,20,33,12,17,10
   简单计算一下：hash(5)=5, 所以数据5应该放在hash表的第5个槽里；hash(28)=1，
   所以数据28应该放在hash表的第1个槽里；hash(19)=1，
   也就是说，数据19也应该放在hash表的第1个槽里——于是就造成了碰撞（也称为冲突，collision）。


17，string-stringbuffer-stringbuilder区别-小米-乐视-百度
   String 字符串常量
   StringBuffer 字符串变量（线程安全）
   StringBuilder 字符串变量（非线程安全）


18 ，  什么是深拷贝和浅拷贝？
  对引用的拷贝，是区别 深拷贝还是浅拷贝的关键，
  实现深拷贝如下：
  public Object clone() throws CloneNotSupportedException{
        Student newStudent = (Student) super.clone();
        newStudent.professor = (Professor) professor.clone();
        return newStudent;
    }



19，堆的结构
   年轻代（Young Generation）、年老代（Old Generation）和持久代（Permanent Generation）
 年轻代（Young Generation）：
    所首先新生成的对象都是放在年轻代的。
 年老代（Old Generation）：
    在年轻代经过了N次GC还存活的对象就会被放到老年代。可以认为年老代中存放的都是一些相对生命周期长的对象
 持久代（Permanent Generation）：
     用于存放静态文件，比如Java类，方法等。持久代对垃圾回收没有显著影响

20 ，Java中 final，finally，finalize 的区别



21， 程序计数器


22， java内存模型经典： https://blog.csdn.net/justloveyou_/article/details/71216049


23,适配器模式，装饰者模式，外观模式的异同？

24,java状态机


25,逻辑地址与物理地址，为什么使用逻辑地址？


26,死锁的四个必要条件




